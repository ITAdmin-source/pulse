# Adding New Tables to the Project

This guide follows the project structure pattern from [takeoff-todo-app](https://github.com/mckaywrigley/takeoff-todo-app) for consistent database and server action organization.

## Project Structure Overview

```
pulse/
├── db/
│   ├── migrations/          # Auto-generated by Drizzle
│   ├── schema/             # Table definitions
│   │   ├── index.ts        # Export all schemas
│   │   └── [table-name].ts # Individual table schemas
│   ├── queries/            # Database query functions
│   │   └── [table-name]-queries.ts
│   └── db.ts              # Database connection
├── actions/               # Next.js Server Actions
│   └── [table-name]-actions.ts
└── drizzle.config.ts      # Drizzle ORM configuration
```

## Step-by-Step Instructions for Adding a New Table

### 1. Create Schema Definition

Create a new file: `db/schema/[table-name].ts`

```typescript
import { pgTable, text, timestamp, uuid, boolean } from "drizzle-orm/pg-core";

export const [tableName] = pgTable("[table_name]", {
  id: uuid("id").defaultRandom().primaryKey(),
  // Add your columns here
  name: text("name").notNull(),
  description: text("description"),
  isActive: boolean("is_active").default(true),
  createdAt: timestamp("created_at").defaultNow().notNull(),
  updatedAt: timestamp("updated_at").defaultNow().notNull(),
});

export type [TableName] = typeof [tableName].$inferSelect;
export type New[TableName] = typeof [tableName].$inferInsert;
```

### 2. Update Schema Index

Add the new schema to `db/schema/index.ts`:

```typescript
export * from "./[table-name]";
// ... other exports
```

### 3. Update Database Connection

Add the new schema to `db/db.ts` in the schema object:

```typescript
import { users, ageGroups, genders, ethnicities, politicalParties, [tableName] } from "./schema";

const schema = {
  users: users,
  ageGroups: ageGroups,
  genders: genders,
  ethnicities: ethnicities,
  politicalParties: politicalParties,
  [tableName]: [tableName], // Add your new table here
};
```

### 4. Create Database Queries

Create a new file: `db/queries/[table-name]-queries.ts`

```typescript
import { eq, desc } from "drizzle-orm";
import { db } from "../db";
import { [tableName], type [TableName], type New[TableName] } from "../schema/[table-name]";

export async function get[TableName]ById(id: string): Promise<[TableName] | undefined> {
  const result = await db
    .select()
    .from([tableName])
    .where(eq([tableName].id, id))
    .limit(1);

  return result[0];
}

export async function getAll[TableName]s(): Promise<[TableName][]> {
  return await db
    .select()
    .from([tableName])
    .orderBy(desc([tableName].createdAt));
}

export async function create[TableName](data: New[TableName]): Promise<[TableName]> {
  const result = await db
    .insert([tableName])
    .values(data)
    .returning();

  return result[0];
}

export async function update[TableName](id: string, data: Partial<New[TableName]>): Promise<[TableName] | undefined> {
  const result = await db
    .update([tableName])
    .set({ ...data, updatedAt: new Date() })
    .where(eq([tableName].id, id))
    .returning();

  return result[0];
}

export async function delete[TableName](id: string): Promise<boolean> {
  const result = await db
    .delete([tableName])
    .where(eq([tableName].id, id));

  return result.rowCount > 0;
}
```

### 5. Create Server Actions

Create a new file: `actions/[table-name]-actions.ts`

```typescript
"use server";

import { revalidatePath } from "next/cache";
import { redirect } from "next/navigation";
import {
  create[TableName],
  delete[TableName],
  get[TableName]ById,
  getAll[TableName]s,
  update[TableName],
} from "@/db/queries/[table-name]-queries";
import { type New[TableName] } from "@/db/schema/[table-name]";

export async function create[TableName]Action(data: New[TableName]) {
  try {
    const [tableName] = await create[TableName](data);
    revalidatePath("/[relevant-path]");
    return { success: true, data: [tableName] };
  } catch (error) {
    console.error("Error creating [table name]:", error);
    return { success: false, error: "Failed to create [table name]" };
  }
}

export async function update[TableName]Action(id: string, data: Partial<New[TableName]>) {
  try {
    const updated[TableName] = await update[TableName](id, data);
    if (!updated[TableName]) {
      return { success: false, error: "[TableName] not found" };
    }
    revalidatePath("/[relevant-path]");
    return { success: true, data: updated[TableName] };
  } catch (error) {
    console.error("Error updating [table name]:", error);
    return { success: false, error: "Failed to update [table name]" };
  }
}

export async function delete[TableName]Action(id: string) {
  try {
    const success = await delete[TableName](id);
    if (!success) {
      return { success: false, error: "[TableName] not found" };
    }
    revalidatePath("/[relevant-path]");
    return { success: true };
  } catch (error) {
    console.error("Error deleting [table name]:", error);
    return { success: false, error: "Failed to delete [table name]" };
  }
}

export async function get[TableName]sAction() {
  try {
    const [tableName]s = await getAll[TableName]s();
    return { success: true, data: [tableName]s };
  } catch (error) {
    console.error("Error fetching [table name]s:", error);
    return { success: false, error: "Failed to fetch [table name]s" };
  }
}

export async function get[TableName]ByIdAction(id: string) {
  try {
    const [tableName] = await get[TableName]ById(id);
    if (![tableName]) {
      return { success: false, error: "[TableName] not found" };
    }
    return { success: true, data: [tableName] };
  } catch (error) {
    console.error("Error fetching [table name]:", error);
    return { success: false, error: "Failed to fetch [table name]" };
  }
}
```

### 6. Generate and Run Migration

After creating the schema, generate a migration:

```bash
npm run db:generate
```

Then apply the migration:

```bash
npm run db:migrate
```

### 7. Common Column Types Reference

```typescript
// Text types
text("column_name")                    // VARCHAR
text("column_name", { length: 255 })   // VARCHAR(255)

// Numbers
integer("column_name")                 // INTEGER
bigint("column_name", { mode: "number" }) // BIGINT
decimal("column_name", { precision: 10, scale: 2 }) // DECIMAL(10,2)

// Dates
timestamp("column_name")               // TIMESTAMP
timestamp("column_name").defaultNow()  // TIMESTAMP DEFAULT NOW()
date("column_name")                    // DATE

// Boolean
boolean("column_name")                 // BOOLEAN
boolean("column_name").default(true)   // BOOLEAN DEFAULT TRUE

// UUID
uuid("column_name").defaultRandom()    // UUID DEFAULT gen_random_uuid()

// JSON
json("column_name")                    // JSON
jsonb("column_name")                   // JSONB

// Arrays
text("tags").array()                   // TEXT[]

// Enums (PostgreSQL)
pgEnum("enum_name", ["value1", "value2", "value3"])

// Foreign Keys
uuid("user_id").references(() => users.id)
```

### 7.1. Working with Enums

When your table includes enum columns, define the enum first, then use it in your table:

#### Option 1: Simple Array Enum
```typescript
import { pgTable, pgEnum, text, uuid, timestamp } from "drizzle-orm/pg-core";

// Define enum
export const statusEnum = pgEnum("status", ["draft", "published", "archived"]);

// Use in table
export const posts = pgTable("posts", {
  id: uuid("id").defaultRandom().primaryKey(),
  title: text("title").notNull(),
  status: statusEnum("status").default("draft").notNull(),
  createdAt: timestamp("created_at", { withTimezone: true }).defaultNow().notNull(),
  updatedAt: timestamp("updated_at", { withTimezone: true }).defaultNow().notNull(),
});
```

#### Option 2: TypeScript Enum Integration
```typescript
import { pgTable, pgEnum, text, uuid, timestamp } from "drizzle-orm/pg-core";

// Utility function for TypeScript enum conversion
function enumToPgEnum<T extends Record<string, string>>(
  myEnum: T,
): [T[keyof T], ...T[keyof T][]] {
  return Object.values(myEnum) as [T[keyof T], ...T[keyof T][]];
}

// TypeScript enum
export enum PostStatus {
  DRAFT = "draft",
  PUBLISHED = "published",
  ARCHIVED = "archived",
}

// PostgreSQL enum
export const postStatusEnum = pgEnum("post_status", enumToPgEnum(PostStatus));

// Use in table
export const posts = pgTable("posts", {
  id: uuid("id").defaultRandom().primaryKey(),
  title: text("title").notNull(),
  status: postStatusEnum("status").default(PostStatus.DRAFT).notNull(),
  createdAt: timestamp("created_at", { withTimezone: true }).defaultNow().notNull(),
  updatedAt: timestamp("updated_at", { withTimezone: true }).defaultNow().notNull(),
});

export type Post = typeof posts.$inferSelect;
export type NewPost = typeof posts.$inferInsert;
```

#### Option 3: Const Array Pattern
```typescript
import { pgTable, pgEnum, text, uuid, timestamp } from "drizzle-orm/pg-core";

// Const array for type safety
export const priorityLevels = ["low", "medium", "high", "urgent"] as const;
export type PriorityLevel = typeof priorityLevels[number];

// PostgreSQL enum
export const priorityEnum = pgEnum("priority", priorityLevels);

// Use in table
export const tasks = pgTable("tasks", {
  id: uuid("id").defaultRandom().primaryKey(),
  title: text("title").notNull(),
  priority: priorityEnum("priority").default("medium").notNull(),
  createdAt: timestamp("created_at", { withTimezone: true }).defaultNow().notNull(),
  updatedAt: timestamp("updated_at", { withTimezone: true }).defaultNow().notNull(),
});
```

**Important Notes for Enums:**
- Define enums **before** the table that uses them
- Export both the enum and the TypeScript types if using TypeScript enums
- Enum names should be unique across your database
- When adding new enum values, they will be added to the end by default
- Consider using descriptive enum names (e.g., `user_status` instead of just `status`)

### 8. Naming Conventions

- **Files**: `kebab-case` (e.g., `user-profiles.ts`)
- **Tables**: `snake_case` (e.g., `user_profiles`)
- **Variables**: `camelCase` (e.g., `userProfile`)
- **Types**: `PascalCase` (e.g., `UserProfile`)
- **Functions**: `camelCase` with descriptive names (e.g., `getUserProfileById`)

### 9. Best Practices

1. **Always include these standard columns**:
   - `id: uuid("id").defaultRandom().primaryKey()`
   - `createdAt: timestamp("created_at").defaultNow().notNull()`
   - `updatedAt: timestamp("updated_at").defaultNow().notNull()`

2. **Use TypeScript types**:
   - Export both select and insert types
   - Use `$inferSelect` and `$inferInsert` from Drizzle

3. **Error handling**:
   - Always wrap database operations in try-catch
   - Return consistent response objects with `success` and `error` fields

4. **Revalidation**:
   - Use `revalidatePath()` in server actions to update cached data
   - Revalidate relevant pages after data mutations

5. **Validation**:
   - Add validation schemas using Zod if needed
   - Validate data in server actions before database operations

### 10. Example Package.json Scripts

Make sure you have these scripts in your `package.json`:

```json
{
  "scripts": {
    "db:generate": "drizzle-kit generate",
    "db:migrate": "drizzle-kit migrate",
    "db:push": "drizzle-kit push",
    "db:studio": "drizzle-kit studio"
  }
}
```

## Quick Checklist

When adding a new table, ensure you:

- [ ] Create schema definition in `db/schema/[table-name].ts`
- [ ] Export schema in `db/schema/index.ts`
- [ ] Add schema to `db/db.ts` schema object
- [ ] Create queries in `db/queries/[table-name]-queries.ts`
- [ ] Create server actions in `actions/[table-name]-actions.ts`
- [ ] Generate migration with `npm run db:generate`
- [ ] Apply migration with `npm run db:migrate`
- [ ] Test CRUD operations
- [ ] Update relevant UI components to use the new actions